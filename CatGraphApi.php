<?php

$debug = false;
$cg_path = dirname(__FILE__);
$gp_path = "$cg_path/gp";

require_once("$cg_path/CatGraphApi.config.php");
if ( !empty($config["gp-lib-path"]) ) $gp_path = $config["gp-lib-path"];

if ( !empty($config["debug"]) ) {
	error_reporting(E_ALL);
	ini_set('display_errors', 1);
}

require_once("$gp_path/gpMediaWiki.php");

/**
 * Base class for output formats
 */
abstract class ApiOutput {
	
	function __construct( $pretty = False, $callback = null ) {
		$this->pretty = $pretty;
		$this->callback = $callback;
		
		$this->ts_start = null;
		$this->ts_last = null;
		
		$this->current_section = null;
	}
	
	/**
	 * Start output. Should print any necessary headers and open any tags, etc.
	 */
	function output_start() {
	}
	
	/**
	 * Prints a block of meta-info about the result.
	 * 
	 * @param array $meta an assoc array containing meta-info about the result.
	 */
	abstract function output_meta( $meta );

	/**
	 * Prints a block of status info.
	 * 
	 * @param array $status an assoc array containing status info.
	 */
	abstract function output_status( $status );

	/**
	 * Prints a block of continuation info for paging.
	 * 
	 * @param array $continue an assoc array containing continuation info.
	 */
	abstract function output_continue( $continue );

	/**
	 * Start log section. 
	 * 
	 * Override to generate output, but chain to enable time tracking.
	 */
	function log_start() {
		$this->current_section = "log";
		
		$this->ts_start = microtime(true);
		$this->ts_last = $this->ts_start;
	}

	/**
	 * shorthand alias for output_log_item().
	 */
	function log( $props ) {
		$this->output_log_item($props);
	}
	
	/**
	 * Prints a log item.
	 * 
	 * @param array $props an assoc array containing the properties of the log item.
	 */
	abstract function output_log_item( $props );

	/**
	 * End log section. 
	 * 
	 * Override to generate output, but chain to enable time tracking.
	 */
	function log_end() {
		$t = microtime(true) - $this->ts_start;
		$this->output_log_item( array("total_time" => $t) );

		$this->current_section = null;
	}
	
	/**
	 * Start data section. 
	 * 
	 * Override to generate output, but chain to enable section tracking.
	 */
	function items_start($fields) {
		$this->current_section = "items";
	}

	/**
	 * Prints a page item in the data section.
	 * 
	 * @param array $page an assoc array containing the properties of page.
	 */
	abstract function output_page_item( $page );

	/**
	 * End data section. 
	 * 
	 * Override to generate output, but chain to enable section tracking.
	 */
	function items_end() {
		$this->current_section = null;
	}

	/**
	 * Terminates the current section.
	 */
	function abort_section() {
		if ( $this->current_section ) {
			$this->current_section = null;
		}
	}
	
	/**
	 * End output.
	 * 
	 * Override to close any tags, etc.
	 */
	function output_end() {
	}

	/**
	 * Return the MIME type of the output generated by this object.
	 */
	abstract function get_content_type();
	
	/**
	 * Send HTTP headers describing the output generated by this object.
	 * 
	 * Per default, this sends a Content-Type header using the
	 * value returned by $this->get_content_type().
	 */
	function send_headers() {
		$ct = 'Content-Type: ' . $this->get_content_type();
		header( $ct );
	}
}

/**
 * Output formatter for JSON. Supports pretty printing and JSONP.
 */
class JsonOutput extends ApiOutput {
	
	/**
	 * Creates new JsonOutput instance.
	 * 
	 * @param bool $pretty if true, the output is pretty-printed. Default is false.
	 * @param str $callback defines the name of the JSONP callback function.
	 *            If $callback is given, the output will be wrapped with a function call,
	 *            as per the JSONP spec.
	 */
	function __construct( $pretty = False, $callback = null ) {
		parent::__construct();
		
		$this->pretty = $pretty;
		$this->callback = $callback;
		
		$this->comma = null;
	}
	
	function escape($value) { # list from www.json.org: (\b backspace, \f formfeed)
		$escapers = array("\\", "/", "\"", "\n", "\r", "\t", "\x08", "\x0c"); 
		$replacements = array("\\\\", "\\/", "\\\"", "\\n", "\\r", "\\t", "\\f", "\\b"); 
		$result = str_replace($escapers, $replacements, $value); 
		return $result; 
	}

	function output_field( $name, $v, $dent = "" ) {
		$this->output_value($name, $dent);
		print ": ";
		$this->output_value($v, $dent);
	}
	
	function output_value( $v, $dent = "" ) {
		if ( $v === null ) print "null";
		else if ( $v === true ) print "true";
		else if ( $v === false ) print "false";
		else if ( is_int($v) ) print $v;
		else if ( is_float($v) ) print sprintf("%8.6f", $v);
		else if ( is_array($v) ) {
			if ( isset($v[0]) ) $this->output_list($v, $dent . "  ");
			else $this->output_props($v, $dent . "  ");
		} else {
			print '"' . $this->escape($v) . '"';
		}
	}
	
	function push_comma( $comma = ", " ) {
		$this->comma = $comma;
	}

	function flush_comma() {
		if ( $this->comma ) {
			print $this->comma;
			$this->comma = null;
		}
	}
	
	function clear_comma() {
		$this->comma = null;
	}
	
	function output_props( $props, $dent = "" ) {
		print "{";

		foreach ( $props as $k => $v ) {
			$this->flush_comma();
			$this->output_field($k, $v, $dent . "  ");
			$this->push_comma();
		}
		
		$this->clear_comma();
		print "}";
	}
	
	function output_list( $props, $dent = "" ) {
		print "[";

		foreach ( $props as $k => $v ) {
			$this->flush_comma();
			$this->output_value($v, $dent . "  ");
			$this->push_comma();
		}
		
		$this->clear_comma();
		print "]";
	}
	
	function output_start() {
		if ( $this->callback ) print $this->callback . "(";
		print "{";
		if ( $this->pretty ) print "\n";
		
		parent::output_start();
	}
	
	function output_meta( $meta ) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t";
		
		$this->output_field("meta", $meta, "  ");
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function output_status( $status ) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t";
		$this->output_field("status", $status, "  ");
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function output_continue( $continue ) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t";
		$this->output_field("continue", $continue, "  ");
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function log_start() {
		$this->flush_comma();
		if ( $this->pretty ) print "\t";
		
		print "\"log\": [";
		if ( $this->pretty ) print "\n";
		
		parent::log_start();
	}

	function output_log_item( $props ) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t\t";

		$now = microtime(true);
		$t = $now - $this->ts_last;
		
		if ($t > 0.005) {
			$props['step_time'] = $t;
			$this->ts_last = $now;
		}
		
		$this->output_props($props, "  ");
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function log_end() {
		parent::log_end();

		$this->clear_comma();
		if ( $this->pretty ) print "\t";
		
		print "]";
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
	}
	
	function items_start($fields) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t";
		
		print "\"items\": [";
		if ( $this->pretty ) print "\n";

		parent::items_start($fields);
	}

	function output_page_item( $page ) {
		$this->flush_comma();
		if ( $this->pretty ) print "\t\t";
		
		$this->output_props($page, "  ");
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function items_end() {
		parent::items_end();

		$this->clear_comma();
		if ( $this->pretty ) print "\t";
		
		print "]";
		
		$this->push_comma();
		if ( $this->pretty ) print "\n";
	}

	function abort_section() {
		if ( $this->current_section ) {
			$this->clear_comma();
			if ( $this->pretty ) print "\t";

			print "]";
			
			$this->push_comma();
			if ( $this->pretty ) print "\n";
		}

		parent::abort_section();
		if ( $this->pretty ) flush();
	}
	
	function output_end() {
		$this->clear_comma();
		print "}";
		if ( $this->callback ) print ")";
		if ( $this->pretty ) print "\n";
		if ( $this->pretty ) flush();
	}

	function get_content_type() {
		if ( $this->pretty ) return "text/plain; charset=utf-8"; #XXX: hack?!
		elseif ( $this->callback ) return "application/json-p; charset=utf-8";
		else return "application/json; charset=utf-8";
	}
}

/**
 * Output formatter for inline HTTP. 
 */
class HtmlOutput extends ApiOutput {
	
	/**
	 * Creates new HtmlOutput instance.
	 * 
	 * @param bool $verbose if true, log items are included in the output. Default is false.
	 */
	function __construct( $verbose = false ) {
		parent::__construct();
		
		$this->verbose = $verbose;
	}
	
	function escape($value) { 
		if ( is_array($value) ) $value = print_r($value, true);
		return htmlspecialchars($value); 
	}
	
	function output_tag( $tag, $value, $attr = "" ) {
		print "<$tag $attr>";
		print $this->escape($value);
		print "</$tag>";
	}
	
	function output_tr( $row, $cell_tag = 'td' ) {
		print "\t\t<tr>";

		foreach ( $row as $v ) {
			print "\t\t\t";
			$this->output_tag($cell_tag, $v);
			print "\n";
		}
		
		print "</tr>\n";
	}

	function output_ol( $row, $attr = "" ) {
		$this->output_ul($row, $attr, "ol");
	}
	
	function output_ul( $row, $attr = "", $tag = "ul" ) {
		print "\t\t<$tag $attr>";

		foreach ( $row as $v ) {
			print "\t\t\t";
			$this->output_tag('li', $v);
			print "\n";
		}
		
		print "</$tag>\n";
	}

	function output_dl( $props, $attr = "" ) {
		print "\t\t<dl $attr>";

		foreach ( $props as $k => $v ) {
			print "\t\t\t";
			$this->output_tag('dt', $k);
			$this->output_tag('dd', $v);
			print "\n";
		}
		
		print "</dl>\n";
	}
	
	function output_header( $title, $tag = "h3", $attr = "" ) {
		print "\t\t";
		$this->output_tag($tag, $title, $attr);
		print "\n";
	}
	
	function output_start() {
		print "<div>";
	}
	
	function output_meta( $meta ) {
		if ($this->verbose) $attr = "";
		else $attr = "style='display:none'";
		
		$this->output_header("Meta", "h3", $attr);
		$this->output_dl( $meta, $attr );
	}

	function output_status( $status ) {
		if ($this->verbose || @$status['status'] != 'ok') $attr = "";
		else $attr = "style='display:none'";
		
		$this->output_header("Status", "h3", $attr);
		$this->output_dl( $status, $attr );
	}

	function output_continue( $continue ) {
		$this->output_header("Continue");
		$this->output_dl( $continue );
	}

	function log_start() {
		if ($this->verbose) $attr = "";
		else $attr = "style='display:none'";
		
		$this->output_header("Log", "h3", $attr);
		print "\t<div $attr>\n";
		
		parent::log_start();
	}

	function output_log_item( $props ) {
		$this->output_tag( 'p', $props );
	}

	function log_end() {
		parent::log_end();
		
		print "\t</div>\n";
	}
	
	function items_start($fields) {
		$this->output_header("Items");
		print "\t<table>\n";

		print "\t\t";
		$this->output_tr( $fields, 'th' );
		print "\n";

		parent::items_start($fields);
	}

	function output_page_item( $page ) {
		$this->output_tr( $page );
	}

	function items_end() {
		parent::items_end();

		print "\t</table>\n";
	}

	function abort_section() {
		if ( $this->current_section == 'items' ) {
			print "</table>\n";
		} elseif ( $this->current_section == 'log' ) {
			print "</div>\n";
		}

		parent::abort_section();
	}
	
	function output_end() {
		print "</div>";
	}

	function get_content_type() {
		return "text/html; charset=utf-8";
	}
}

/**
 * outputs an error message and terminates. This function never returns normally,
 * but it may be changed in the future to throw an exception under some circumstances.
 * 
 * If $output is given, $output->abort_section() and $output->output_status() are used
 * to terminate normal output and report the error in a way that conforms to the current
 * output format.
 * 
 * @param str $msg the message to show
 * @param $output (optional) an ApiOutput instance
 **/
function die_with_error( $msg, $output = null ) {
	if ( $output ) {
		$status = array(
			'status' => 'error',
		);

		if ( is_object($msg) && $msg instanceof Exception ) {
			$status['type'] = get_class($msg);
			$status['message'] = $msg->getMessage();
		} else {
			$status['message'] = $msg;
		}
		
		$output->abort_section();
		$output->output_status( $status );
		$output->output_end();

		die();
	} else {
		die($msg);
	}
}

/**
 * Returns a gp client (of type MediaWikiGlue) for querying the wiki's database
 * and the associated category graph in a unified way. Relies on the global $config
 * variable to provide information about the desired wiki.
 * 
 * @param str $wiki the name of the wiki (must be a key in the global $config array).
 *        if $wiki is not in $config, die_with_error() is called, which may cause an
 * 		  exception or completely terminate the script.
 */
function create_gp_client( $wiki ) {
	global $config;
	
	#TODO: if $config doesn't know $wiki, look it up in toolserver.wikis!
	
	if ( !isset( $config[ $wiki ] ) ) {
		die_with_error("unknown wiki: $wiki");
	}
	
	$gp_graph = $config[ $wiki ][ 'gp-graph' ];
	$gp_host = @$config[ $wiki ][ 'gp-host' ];
	$gp_port = @$config[ $wiki ][ 'gp-port' ];

	$gp = gpMediaWikiGlue::new_client_connection( $gp_graph, $gp_host, $gp_port ); #todo: optional auth
	$gp->connect();
	
	$v = $gp->protocol_version();
	
	$mysql_host = @$config[ $wiki ][ 'mysql-host' ];
	$mysql_user = $config[ $wiki ][ 'mysql-user' ];
	$mysql_password = @$config[ $wiki ][ 'mysql-password' ];

	$mysql_database = $config[ $wiki ][ 'mysql-database' ];
	$mysql_prefix = @$config[ $wiki ][ 'mysql-prefix' ];
	$mysql_temp_db = @$config[ $wiki ][ 'mysql-temp-db' ];

	$gp->mysql_connect($mysql_host, $mysql_user, $mysql_password);
	$gp->mysql_select_db($mysql_database);
	$gp->prefix = $mysql_prefix;
	$gp->temp_table_db = $mysql_temp_db;
	
	return $gp;
}

/**
 * Creates and returns an ApiOutput instance for generating the format
 * specified by teh $format parameter. Supported formats:
 * 
 * * json, jsonp: generate JSON output. if $options['callback'] is present,
 *                use that to determin the wrapper function for a JSONP response.
 * * inline, html:  generate inline HTML.
 * * pjson, pjsonp: generate pretty printed JSON.
 * * debug, text:   generate human readable debug putput. Currently
 *                  the same as pjson.
 * 
 * @param str $format the format specifier. 
 * @param array $options (optional) an assoc array that may provide options
 *        the output object, such as the 'callback' parameter for JSPNP.
 */
function create_output_handler( $format, $options = null ) {
	$callback = @$options['callback'];
	
	if ( $callback && !preg_match( '/^[a-zA-Z_\$]\w*$/', $callback ) ) {
		$callback = null;
	}
	
	if ( $format == "json" || $format == "jsonp" )  return new JsonOutput( false, $callback );
	if ( $format == "inline" || $format == "html" ) return new HtmlOutput( false );
	if ( $format == "pjson" || $format == "pjsonp" )  return new JsonOutput( true, $callback );
	if ( $format == "debug" || $format == "text" )  return new JsonOutput( true, $callback );
	
	die_with_error("unknown format: $format");
}

/**
 * Creates and returns a PageSet object (see gpMediaWiki.php) containing
 * pages from the categories specified by $cats. Additional options taken
 * from $options:
 * 
 * * depth: the maximum depth to search in the category structure.
 * * ns: the namespace(s) to search for pages. If this is "14", only
 *       categories will be included in the page set. Otherwise, all
 *       pages are included. Further filtering for the desired namespaces
 *       is performed later by filter_namespace_set().
 * 
 * @param gpConnection $gp the graph processor handle.
 * @param str $cats the categories to search, multiple categories can be 
 *            separated by pipes ("|"). 
 * @param array $options an associative arary providing additional options.
 * @param str $opt_suffix a suffix to apply to option names in $options.
 *        options with that suffix will be preferred, options without the 
 *        suffix act as a default.
 * @param object $log an object supporting the log() method for reporting
 *        progress.
 */
function make_page_set( $gp, $cats, $options, $opt_suffix, $log) {
	$depth = @$options['depth'.$opt_suffix]; #FIXME: validate
	if (!$depth) $depth = @$options['depth']; #FIXME: validate
	if (!$depth) $depth = 100; #FIXME: configure

	$graph_type = $gp->get_meta_value('gpfeeder_graph_type');

	#NOTE: no per-suffix namespace option, because namespaces are filtered globally later by filter_page_set()!
	$ns    = @$options['ns'];    #FIXME: validate #FIXME: without
	
	$pages = new gpPageSet($gp);
	$pages->create_table();
	#TODO: implement tracking for execution times in gpPageSet

	#XXX: make $cats default to all roots?
	$cats = explode('|', $cats);
	$log->log( array( "categories" => $cats ) );
	
	foreach ( $cats as $cat ) {
		$pages->add_subcategories( $cat, $depth ); #FIXME: "add_subcategories" is now misleadingly named, rename to "add_descendants" or some such

		if ( $graph_type == "with-leafs" ) {
			$log->log( array( "list" => "descendants", "category" => $cat, "depth" => $depth, "items" => $pages->size() ) );
		} else {
			$log->log( array( "list" => "subcategories", "category" => $cat, "depth" => $depth, "items" => $pages->size() ) );
		}
	}
	
	if ( $ns !== (string)NS_CATEGORY ) { 
		#FIXME: if $graph_type == "with-leafs", compare gpfeeder_namespaces with $ns.
		
		if ( $graph_type != "with-leafs" ) {
			$pages->expand_categories();
			$log->log( array( "expand" => "categories", "items" => $pages->size() ) );
		} 
	}
	
	return $pages;
}

/**
 * Extracts a multi-value option from $options. Multi-value options are
 * represented by one entry in $options for each value, using a numeric
 * suffix to the option name. For instance, to provide three values for 
 * the option "foo", one would use the keys "foo1", "foo2", and "foo3".
 * "foo" without a suffix is considered equivalent to "foo1".
 * 
 * Multi-value options should not be confused with list-like options, which
 * are given as a single string in $options, with the list items separated by
 * pipes ("|") or some other special character.
 * 
 * @param array $options an associative array of options.
 * @param str $name the option name
 * @param int $max the maximum suffix to scan (default: 16).
 */
function get_multi_option( $options, $name, $max = 16 ) {
	$values = array();
	
	if ( isset($options[$name]) ) {
		if ( $options[$name] !== '' ) {
			$values[''] = $options[$name];
		}
		
		if ( isset($options[$name.'1']) ) $n = 1;
		else $n = 2;
	} elseif ( isset($options[$name.'1']) ) {
		if ( $options[$name.'1'] !== '' ) {
			$values[1] = $options[$name.'1'];
		}
		
		$n = 2;
	} else {
		$n = false;
	}
	
	# find more values
	while ( $n && $n < $max ) {
		if ( isset($options[$name.$n]) 
			&& $options[$name.$n] !== '' 
			&& $options[$name.$n] !== false
			&& $options[$name.$n] !== null ) { #NOTE: '0' and 0 are not skipped!
				
			$values[$n] = $options[$name.$n];
		}
		
		$n += 1;
	}
	
	return $values;
}

/**
 * Takes a user-provided date an turns it into a MediaWiki-style timestamp
 * (YYYYMMDDHHMMSS, with no separators).
 * 
 *	$date should be of the form  `YYYY-MM-DD HH:MM:SS`, meaning year, month
 *	and day followed by hour (24 hour base), minutes and seconds. The
 *	seconds part or the entire time part may be omitted, leaving only
 *	the date. The separators (dash "-", space " " and colon ":") are
 *	optional, but they must either be all present or all omitted. Examples:
 *		
 *	- 2011-12-20 15:00:00: 3pm on December 20, 2011.
 *	- 2011-12-20 15:00: also 3pm on December 20, 2011.
 *	- 201112201500: also 3pm on December 20, 2011.
 *	- 2011-12-20 15: *invalid!*
 *	- 2011-12-20: midnight before December 20, 2011.
 *	- 20111220: also midnight before December 20, 2011.
 *	- 20111220 15:00: *invalid!*
 *	 
 *	The date may also be given relative to the current time, using a
 *	number followed by "d", "h" or "m", signifying a number of days,
 *	hours or minutes respectivley. So, "2d" means "two days ago" and
 *	"5m" means "five minutes ago". 
 *	
 *	Note that relative times are subject to clock skew between the wiki
 *	server and the server running the CatGraphApi.
 * 
 * @param str $date the date as provided by the user
 * @throws Exception if $date is malformed
 * @returns str the date as a MediaWiki timestamp.
 **/
function normalize_date( $date ) {
	if ( empty($date) ) return null;
	
	$orig = $date;
	$date = trim($date);
	
	if ( preg_match('/^(\d+)([dhm])$/', $date, $m) ) {
		$u = strtoupper($m[2]);
		$min = (int)$m[1];
		
		if ( $u == "D" ) $min = $min * 60 * 24;
		else if ( $u == "H" ) $min = $min * 60;
		
		$t = time() - (60*$min); #subtract seconds from current epoch
		
		$date = date("YmdHis", $t); #NOTE: relies on date_default_timezone_set ( "UTC" )
	}
	
	if ( preg_match('/^(\d{4})-(\d{1,2})-(\d{1,2})/', $date, $m) ) {
		$date = substr($date, strlen($m[0]));
		$date = sprintf("%04d%02d%02d", $m[1], $m[2], $m[3]) . $date;
	}
	
	if ( preg_match('/(\d{1,2}):(\d{1,2}):(\d{1,2})$/', $date, $m) ) {
		$date = substr($date, 0, strlen($date) - strlen($m[0]));
		$date = $date . sprintf("%02d%02d%02d", $m[1], $m[2], $m[3]);
	} elseif ( preg_match('/(\d{1,2}):(\d{1,2})$/', $date, $m) ) {
		$date = substr($date, 0, strlen($date) - strlen($m[0]));
		$date = $date . sprintf("%02d%02d%02d", $m[1], $m[2], 0);
	}
	
	$date = preg_replace('/(\d+)(\s*T\s*|\s+)(\d+)/', '\1\3', $date);
	
	$date = str_pad( $date, 14, "0" );
	
	if ( !preg_match('/^(20\d\d)([01]\d)([0123]\d)([01]\d)([012345]\d)([0123456]\d)$/', $date) ) {
		throw new Exception("malformed date: $orig ($date)");
	}
	
	return $date;
}

/**
 * Takes a user-provided size and returns it as an int.
 * 
 * $size must be an integer in decimal notation, optionally
 *       followed by a unit specifier. Supported units are:
 * 
 * * K: Kilo, the value is multiplied by 1024.
 * * M: Mega, the value is multiplied by 1024*1024.
 * 
 * @param str $size the size as provided by the user
 * @throws Exception if $size is malformed
 * @returns int the size as an integer.
 **/
function normalize_size( $size ) {
	if ( empty($size) ) return null;
	
	$orig = $size;
	$size = trim($size);
	
	if ( preg_match('/^(\d+)([kmKM])[bB]?$/', $size, $m) ) {
		$u = strtoupper($m[2]);
		$size = (int)$m[1];
		
		if ( $u == "K" ) $size = $size * 1024;
		else if ( $u == "M" ) $size = $size * 1024 * 1024;
		
		$size = "$size";
	}
	
	if ( !preg_match('/^\d+$/', $size) ) {
		throw new Exception("malformed size: $orig");
	}
	
	return (int)$size;
}

/**
 * Checks well-known filter options for syntax errors.
 * If any well known option is malformed, an Exception is thrown.
 */
function check_filter_options( $options ) {
	$since  = normalize_date(@$options['since']);  
	$newer  = normalize_date(@$options['newer']);  
	$older  = normalize_date(@$options['older']);  
	$larger = normalize_size(@$options['larger']); 
	$smaller = normalize_size(@$options['smaller']);
}

/**
 * checks page sets with the given base name. If any of the pages in any of the page sets
 * isn't found in the database, an exception is thrown.
 * 
 * @param gpConnection $gp the graph processor handle.
 * @param array $options an associative array defining which pages to return.
 * @param str $name the base name of the page sets. See get_multi_option() for details.
 * @param int $ns the namespace in which to look for the given pages (as a numeric id)
 */
function check_page_sets( $gp, $options, $name, $ns ) {
	$page_sets = get_multi_option($options, $name);
	
	foreach ( $page_sets as $n => $set ) { #for each page set
		extract_not( $set ); # strip <not>, if present
		$pages = explode('|', $set); # explode page set
		
		foreach ( $pages as $title ) {
			$gp->get_page_id( $ns, $title ); #throws an exception if page is not found
		}
	}
}

/**
 * Applies the filters specified in $options to the page set $pages.
 * Supported filters are:
 * 
 * * since: keep only pages modified since the given date. See normalize_date() for the format.
 * * newer: keep only pages created since the given date. See normalize_date() for the format.
 * * older: keep only pages modified before the given date. See normalize_date() for the format.
 * * larger: keep only pages that are larger than the given size. See normalize_size() for the format.
 * * smaller: keep only pages that are smaller than the given size. See normalize_size() for the format.
 * * template: filter by template inclusion in the page. 
 * * ns: filter by nymespace. ns is a pipe separated list of numeric namespace ids.
 * 
 * Filtering by template may be complex: Multiple lists 
 * of templates may be given in separate options using suffixes,
 * i.e. template, template2, template3 and so on. Each list
 * is applied as a filter to the page set successivley, keeping
 * only pages that contain one of the templates in the list.
 * This may be inverted to removing pages containing these 
 * templates by either prefixing the list with "<not>", or
 * by setting template_not (resp template_not2, template_not3, ...)
 * to "not". So, if we set template="X|Y" and template2="<not>A|B",
 * we get only pages that contain X or Y but do not contain A or B.
 * 
 * @param PageSet $pages the page set to filter
 * @param array $options an associative array of filter options.
 * @param object $log an object supporting the log() method for reporting
 *        progress.
 */
function filter_page_set( $pages, $options, $log ) {
	$tags   = get_multi_option($options, 'template');    
	
	$since  = normalize_date(@$options['since']);  
	$newer  = normalize_date(@$options['newer']); #FIXME: doesn't work! #BROKEN! 
	$older  = normalize_date(@$options['older']); #FIXME: doesn't work! #BROKEN! 
	$larger = normalize_size(@$options['larger']); 
	$smaller = normalize_size(@$options['smaller']);

	$ns    = @$options['ns'];    #FIXME: validate #FIXME: without #TODO: allow localized names and aliasses

	if ( $tags ) {
		foreach ( $tags as $n => $tag ) {
			$not = extract_not( $tag ) || @$options["template{$n}_not"];
			$allowed_tags = explode('|', $tag); 
			
			if ( $not ) {
				$pages->strip_transcluding( $allowed_tags );
				$log->log( array( "filter" => "without-templates", "templates" => $allowed_tags, "items" => $pages->size() ) );
			} else {
				$pages->retain_transcluding( $allowed_tags );
				$log->log( array( "filter" => "templates", "templates" => $allowed_tags, "items" => $pages->size() ) );
			}
		}
	}

	if ( $larger ) {
		$pages->retain_larger( $larger );
		$log->log( array( "filter" => "larger", "larger" => $larger, "items" => $pages->size() ) );
	}

	if ( $smaller ) {
		$pages->retain_smaller( $smaller );
		$log->log( array( "filter" => "smaller", "smaller" => $smaller, "items" => $pages->size() ) );
	}

	if ( $older ) {
		$pages->retain_older( $older );
		$log->log( array( "filter" => "older", "older" => $older, "items" => $pages->size() ) );
	}

	if ( $newer ) {
		$pages->retain_newer( $newer );
		$log->log( array( "filter" => "newer", "newer" => $newer, "items" => $pages->size() ) );
	}
	
	$pages->resolve_ids();
	$log->log( array( "resolve" => "titles", "items" => $pages->size() ) );

	#TODO: don't filter if the list of requested namespaces is the same as the list in the meta-var gpfeeder-namespaces.
	if ( $ns !== null && $ns !== "" ) {
		$ns = explode('|', $ns);
		
		$pages->retain_namespace( $ns );
		$log->log( array( "filter" => "namespace", "ns" => $ns, "items" => $pages->size() ) );
	}

	if ( $since ) {
		$pages->retain_modified_since( $since );
		$log->log( array( "filter" => "since", "since" => $since, "items" => $pages->size() ) );
	}

	#TODO: orphans, deadends
}

/**
 * Removes any leading "<not>" from $list. Note that $list is a reference
 * parameter, so the variable used to call this function gets modified.
 * 
 * @return bool true if "<not>" was found, false otherwise.
 */
function extract_not( &$list ) {
	if ( preg_match('/^(<not>)(.*)$/', $list, $m ) ) {
		$list = $m[2];
		return true;
	}
	
	return false;
}

/**
 * Generates a list of pages based on $options and outputs it using $output.
 * This implements the "list" operation of the CatGraph API.
 * 
 * To provide a base set to work on, list_pages() requires $options['cat']
 * (or $options['cat1']) to be set. The "cat" option defines a list of
 * categories, causing pages that are in any of those categories (or their
 * subcategories) to be included in the base set (see make_page_set() for
 * details and additional options).
 * 
 * Multiple page sets may be given in separate options using suffixes,
 * i.e. cat, cat2, cat3 and so on. Each set is generated separately and
 * in turn intersected with the base set, so that only pages in both sets
 * remain. This effect may be inverted to removing pages contained in  
 * both sets by either prefixing the list with "<not>", or
 * by setting cat_not2 (resp cat_not3, cat_not4, ...) to "not". 
 * So, if we set cat="X|Y" and cat2="<not>A|B", we get only pages
 * contained in the categories X or Y but not contained in A or B (including
 * subcategories to some depth, see make_page_set()).
 * 
 * After all page sets have been processed, filter_page_set() is used to
 * apply additional filters to the remainign page set, producing the final
 * result.
 * 
 * @param gpConnection $gp the graph processor handle.
 * @param array $options an associative array defining which pages to return.
 * @param ApiOutput $output an output object for printing the resulting page
 *        set in the desired format.
 */
function list_pages($gp, $options, $output) {
	check_filter_options( $options ); # check filter options early

	check_page_sets( $gp, $options, 'cat', NS_CATEGORY ); # check cat page set early
	check_page_sets( $gp, $options, 'template', NS_TEMPLATE ); # check template page set early

	$output->log_start();
	
	# get initial set
	$categories   = get_multi_option($options, 'cat');
	
	if ( !$categories ) {
		die_with_error("no category specified", $output);
	}
	
	$pages = null;
	
	# intersect with more sets
	foreach ( $categories as $n => $cat ) {
		$not = extract_not( $cat ) || @$options["cat{$n}_not"];
		
		$cat_pages = make_page_set( $gp, $cat, $options, $n, $output );
		
		if ( !$pages ) { #first cat set
			if ( $not ) {
				die_with_error("base set can not be inverted (don't use <not> on first cat-parameter)", $output);
			}

			$pages = $cat_pages;
			$output->log( array( "base" => "category", "category" => $cat, "items" => $pages->size() ) );
		} else {
			if ( $not ) {
				$pages->subtract_page_set( $cat_pages );
				$output->log( array( "filter" => "without", "category" => $cat, "items" => $pages->size() ) );
			} else {
				$pages->retain_page_set( $cat_pages );
				$output->log( array( "filter" => "cut", "category" => $cat, "items" => $pages->size() ) );
			}
		}
		
		$n += 1;
	}
	
	# apply filters
	filter_page_set( $pages, $options, $output ); #XXX: really apply one, to final result? or better do it for each set?
	
	$output->log_end();
	
	$src = $pages->make_source();
	
	$output->items_start( array(
		'id', 'ns', 'title',
	));
	
	$n = 0;
	
	while ( ( $row = $src->nextRow() ) ) {
		$rec = array("id" => (int)$row[0], 
					"ns" => (int)$row[1], 
					"title" => $row[2]    #TODO: generate title with localized namespace prefix!
					);
		
		#TODO: allow for extra fields (add enrich-function to page set); e.g. image_mime, rev_id
		
		$output->output_page_item( $rec ); 
		$n += 1;
	} 
	
	$output->items_end();
	
	return $n;
}

/**
 * Returns a list of supported wikis as an associative array. They keys in the array
 * are the wiki names (internal identifiers, typically enwiki, etc), the values
 * are the display labels (typically domain names, e.g. en.wikipedia.org).
 * 
 * The list is currently derived from the global $config array: each
 * section in the configuration (except "DEFAULT") is considered to describe
 * a wiki. If the section contains a "label" field, this is used as the wiki's
 * label, otherwise the section's name is used.
 * 
 * In the future, this list may be built based on database content or
 * some other source.
 */
function get_wiki_list() {
	global $config;
	
	$wikis = array();
	
	foreach ($config as $k => $v) {
		if ( is_array($v) && $k != "DEFAULT" ) {
			if ( !empty($v['label']) ) $label = $v['label'];
			else $label = $k;
			
			$wikis[$k] = $label;
		}
	}
	
	return $wikis;
}

/**
 * Calculates the requested page set and outputs it. This is the main entry
 * point to the API. It connects to graphserv and mysql, prepares the output
 * formatter, and then calls an appropriate function for handlign the operation 
 * specified by the $op parameter. Currently supported operations are:
 * 
 * * list (list a set of pages based on categories and other options).
 * 
 * @param str $format the desired output format
 * @param str $wiki the wiki to work on
 * @param str $op the operation to perform
 * @param array $options an associative array providing the parameters for
 *        the operation, typically derived from $_REQUEST.
 */
function generate_response($format, $wiki, $op, $options) {
	$output = create_output_handler( $format, $options );

	if ( $format == "debug" ) {
		# flush and end all output buffers
		while (ob_get_level()) {
			ob_end_clean();
		}
	}

	if ( !headers_sent() ) {
		$output->send_headers();
	}
	
	$output->output_start();
	
	try {
		$gp = create_gp_client( $wiki );
	
		if ( $op == 'list' ) {
			$n = list_pages( $gp, $options, $output ); 
		} 
		#TODO: op=path -> show path to root, shorted path between

		$status = array(
			'status' => 'ok',
			'items' => $n,
		);

		$output->output_status($status);
		$output->output_end();
	} catch (Exception $e) {
		die_with_error($e, $output); #FIXME: don't die in inline mode!
	}
}

/**
 * Outputs an HTML text field and associated label.
 * 
 * @param str $name the form element name
 * @param str $label the label to show along with the field. If NULL, no label tag will be printed.
 * @param int $size determins the maxlength and size of the field.
 * @param array $options associative option array, typically $_REQUEST. $options[$name] is used to 
 *              determin the initial value of the text field.
 * @param str $attr additional attributes to apply to the text field, as a string.
 */
function print_text_field($name, $label, $size, $options, $attr = '') {
	$value = @$options[$name];
	
	if ( (int)$size ) {
		$attr .= " size=\"$size\"";
		$attr .= " maxlength=\"$size\"";
	}
	
	if ($label) print '<label for="'.htmlspecialchars($name).'">'.htmlspecialchars($label).'</label>&nbsp;';
	print '<input name="'.htmlspecialchars($name).'" type="text" value="'.htmlspecialchars($value).'" '.$attr.'/>';
}

/**
 * Outputs an HTML selection element and associated label.
 * 
 * @param str $name the form element name
 * @param str $label the label to show along with the field. If NULL, no label tag will be printed.
 * @param int $choices the choices to offer in the selector. If this is an associative array, the keys
 *            are used as the option's values and the values are used as the labels.
 * @param array $options associative option array, typically $_REQUEST. $options[$name] is used to 
 *              determin the default selection.
 * @param str $attr additional attributes to apply to the text field, as a string.
 */
function print_select($name, $label, $choices, $options) {
	$value = @$options[$name];
	
	if ($label) print '<label for="'.htmlspecialchars($name).'">'.htmlspecialchars($label).'</label>&nbsp;';

	print '<select name="'.htmlspecialchars($name).'"/>';
	
	$assoc = true;
	
	if ( isset($choice[0]) ) $assoc = false;
	if ( isset($choice['']) ) $assoc = true;
	
	foreach ($choices as $v => $s) {
		if ( !$assoc ) {
			$v = $s;
		}
		
		$a='';
		
		if ((string)$v === (string)$value) {
			$a .= ' selected="selected"';
		}
		
		print '<option value="'.htmlspecialchars($v).'" '.$a.'>'.htmlspecialchars($s).'</option>';
	}
	
	print '</select>';
}

/**
 * Outputs HTML for a form section for filtering by the templates contained on a page.
 * This includes a selector for picking the mode ("with" or "without" the template),
 * and an input field for the template name(s).
 * 
 * Parameters generated by these form elements are handled by the filter_pages() function.
 * 
 * @param str $number the filter's number, used as a suffix to the field name "template".
 * @param str $templ the initial value of the input field. Typically the same 
 *              as $options["template{$number}"].
 * @param array $options associative option array, typically $_REQUEST. 
 *              Among other things, $options["template{$number}_not"] is used to 
 *              determin the currently selected mode.
 */
function print_template_filter_section($number, $templ, $options) {
	$not = @$options["template{$number}_not"];
	
	?>
		<p id='<?php print "template{$number}_filter_section"; ?>'>
			<select name='<?php print "template{$number}_not"; ?>'>
				<option value="" <?php print $not ? "" : "selected='selected'"; ?>>with</option>
				<option value="not" <?php print $not ? "selected='selected'" : ""; ?>>without</option>
			</select>

			<label for='<?php print "template{$number}"; ?>'>template</label>
			<input type="text" name='<?php print "template{$number}"; ?>' value="<?php print htmlspecialchars($templ); ?>"/>
		</p>
	<?php
}

/**
 * Outputs HTML for a form section for filtering by the category a page is in.
 * This includes a selector for picking the mode ("also in" or "not in" the category),
 * and an input field for the category name(s).
 * 
 * Parameters generated by these form elements are handled by the list_pages() function.
 * 
 * @param str $number the filter's number, used as a suffix to the field name "cat".
 * @param str $cat the initial value of the input field. Typically the same 
 *              as $options["cat{$number}"].
 * @param array $options associative option array, typically $_REQUEST. 
 *              Among other things, $options["cat{$number}_not"] is used to 
 *              determin the currently selected mode.
 */
function print_cat_filter_section($number, $cat, $is_base, $options) {
	if ( $is_base ) $not = false;
	else $not = @$options["cat{$number}_not"];
	
	?>
		<p id='<?php print "cat{$number}_filter_section"; ?>'>
			<?php if (!$is_base) { ?>
				<select name='<?php print "cat{$number}_not"; ?>'>
					<option value="" <?php print $not ? "" : "selected='selected'"; ?>>also in</option>
					<option value="not" <?php print $not ? "selected='selected'" : ""; ?>>not in</option>
				</select>
				in
			<?php } else { ?>
				<label for='<?php print "cat{$number}"; ?>'>and in catgeory</label>
			<?php } ?>

			<input type="text" name='<?php print "cat{$number}"; ?>' value="<?php print htmlspecialchars($cat); ?>"/>
		</p>
	<?php
}

date_default_timezone_set( "UTC" ); #NOTE: same time zone as database timestamps (should always be utc)

$op = false;
$format = false;

if ( @$_REQUEST['op'] ) {
	#operation requested
	
	$wiki = $_REQUEST['wiki'];
	$op = $_REQUEST['op'];
	$format = @$_REQUEST['format'];
	
	if ( !$format ) $format = 'inline';
	
	if ( $format != 'inline' ) { # if format is "inline", generate output later, inside the html output.
	
		# ***** THIS IS WHERE IT ALL HAPPENS! *************************************************

		# generate page set and output it. 
		generate_response($format, $wiki, $op, $_REQUEST); 
		exit(); # output complete, that's it.
	}
}

# start HTML output
# either no operation was requested, or the output format is given as "inline"

header( "Content-Type: text/html; charset=utf-8" );

?>
<html>
<head>
	<title>CatGraphApi</title>
	
	<script type="text/javascript">//<!--

		/**
		 * enables or disables all form fields that are children
		 * of the given root element. Usedful for ignoring any input
		 * in a currently invisible part of a form, without losing the
		 * input.
		 */
		function set_fields_enabled( root, enabled ) {
			var n = root.firstChild;
			
			while ( n ) {
				if ( n instanceof Element ) {
					if ( n.name ) {
						n.disabled = !enabled;
					} else if ( n.firstChild )  {
						set_fields_enabled(n, enabled);
					}
				}
				
				n= n.nextSibling;
			}
		}
		
		/**
		 * attach buttons for collapsing and expanding the specified section.
		 */
		function make_toggle_buttons( section_id, visible ) {
			var expand_button = document.getElementById("toggle_expand_button_prototype").cloneNode(true);
			var collapse_button = document.getElementById("toggle_collapse_button_prototype").cloneNode(true);

			var section = document.getElementById(section_id);
			
			expand_button.id = null;
			collapse_button.id = null;
			
			expand_button.onclick = function( e ) {
				expand_button.style.display = "none";
				collapse_button.style.display = "inline";
				section.style.display = "block";
				set_fields_enabled(section, true);
			};
			
			collapse_button.onclick = function( e ) {
				expand_button.style.display = "inline";
				collapse_button.style.display = "none";
				section.style.display = "none";
				set_fields_enabled(section, false);
			};
			
			if ( visible == false ) {
				section.style.display = "none";
			} else if ( visible == true )  {
				section.style.display = "block";
			}

			if ( section.style.display == "none" || section.style.visibility == "hidden" ) {
				expand_button.style.display = "inline";
				collapse_button.style.display = "none";
			} else {
				expand_button.style.display = "none";
				collapse_button.style.display = "inline";
			}
			
			section.parentNode.insertBefore(expand_button, section.nextSibling);
			section.parentNode.insertBefore(collapse_button, section.nextSibling);
		}

		/**
		 * Attaches a [+]-button to the section with the id prefix + number + "_filter_section".
		 * The [+]-button triggers on_add_filter(), which clones the section, 
		 * adjusts any ids and inserts it below the original section.
		 */
		function make_add_filter_button( prefix, number ) {
			var button = document.getElementById("add_filter_button_prototype");
			button = button.cloneNode(true);

			var section = document.getElementById(prefix + number + "_filter_section");
			
			//if (!button) return;
			//if (!section) return;
			
			section.filter_number = number;
			section.filter_name = prefix;
			
			if (!number) next = 2;
			else next = number +1;
			
			button.id = prefix + "_add_filter_button";
			button.style.display = "inline";
			
			button.onclick = function( e ) {
				on_add_filter( button );
			};
			
			section.insertBefore(button, section.lastChild);
		}

		/**
		 * Handles a [+]-button for adding another filter section. 
		 * It takes the section containing the button, clones it,
		 * adjusts any ids and inserts it below the original section.
		 * Finally, it moves the button to the new section.
		 */
		function on_add_filter( button ) {
			var this_section = button.parentNode;
			var number;
			
			if (!this_section.filter_number) number = 2;
			else number = this_section.filter_number +1;
			
			var prefix = this_section.filter_name;
			
			if ( button.parentNode ) {
				button.parentNode.removeChild(button);
			}

			var new_section = this_section.cloneNode(true);
			new_section.id = prefix + number + "_filter_section";
			new_section.filter_number = number;
			new_section.filter_name = prefix;
			
			var name_pattern = new RegExp('^('+prefix+'\\d*)(.*)$');
			var n = new_section.firstChild;
			
			while ( n ) {
				if ( n instanceof Element ) {
					if ( n.name && (m = name_pattern.exec(n.name)) ) {
						n.name = prefix + number + m[2];
					}
				
					if ( n.htmlFor && (m = name_pattern.exec(n.htmlFor)) ) {
						n.htmlFor = prefix + number + m[2];
					}

					if ( n.nodeName == 'INPUT' && n.type == 'text' && n.value ) {
						n.value = '';
					}
				}
				
				n= n.nextSibling;
			}
			
			new_section.insertBefore(button, new_section.lastChild);
			this_section.parentNode.insertBefore(new_section, this_section.nextSibling);
		}
	//-->
	</script>
	
	<style type="text/css"> 
		html, body {
			font-family: sans-serif;
			font-size: 1em;
		}
	
		.notice {
			border: 1px solid black;
			background-color: #FFFFAA;
			margin: 1ex 0;
			padding: 1ex;
			font-weight: bold;
			text-align: center;
		}
		
		#main {
			padding: 1ex;
			float:left;
		}

		#filterform {
			border: 1px solid black;
			background-color: #EEEEEE;
			margin: 1ex 0;
			padding: 1ex;
		}
	</style>
</head>
<body>
	<div id="main">
	<h1>CatGraphApi</h1>
	
	<?php
	# show notice, if configured
	if ( !empty( $config['notice'] ) ) {
		print "<div class='notice'>" . htmlspecialchars($config['notice']) . "</div>";
	}
	?>
	
	<form id="filterform">
		<!-- /* button prototypes */ -->
		<input id="add_filter_button_prototype" type="button" value="+" style="display:none"/>
		<input id="toggle_expand_button_prototype" type="button" value="more..." style="display:none"/>
		<input id="toggle_collapse_button_prototype" type="button" value="(hide)" style="display:none"/>
		
		<p> 
			List pages <input type="hidden" name="op" value="list"/>
			
			<!-- /* currently no choices! */
			<label for="op">Operation</label>
			<select name="op">
				<option value="list">List pages</option>
			</select>
			-->

			<?php 
				# make wiki selector

				$wikis = get_wiki_list();
				print_select("wiki", "on wiki", $wikis, $_REQUEST); 
			?>
			and in
			<?php 
				# make namespace selector

				$choices = array(
					'' => 'all',
					NS_MAIN => 'Articles',
					NS_CATEGORY => 'Categories',
					NS_FILE => 'Files',
				);
				
				print_select("ns", "namespace", $choices, $_REQUEST); 
			?>
		</p>
		
		<?php
			# make category filter sections (as many as needed to represent
			# the filters in $_REQUEST, but at least one)

			$cats = get_multi_option($_REQUEST, 'cat');
			if ( !$cats ) $cats = array( '' => '', 2 => '' ); # print two empty fields
			
			if ( count($cats)<2 ) {
				$vv = array_values($cats);
				$cats = array( '' => $vv[0], 2 => '' ); # add a second empty field
			}
			
			$is_base = true;
			foreach ( $cats as $n => $cat ) {
				print_cat_filter_section($n, $cat, $is_base, $_REQUEST);
				$is_base = false;
			}
		?>
		<script>make_add_filter_button('cat', <?php print $n ? (int)$n : "''"; ?>)</script>

		<?php
			# make template filter sections (as many as needed to represent
			# the filters in $_REQUEST, but at least one)

			$templates = get_multi_option($_REQUEST, 'template');
			if ( !$templates ) $templates = array( '' => '' ); # print one empty field
			
			foreach ( $templates as $n => $templ ) {
				print_template_filter_section($n, $templ, $_REQUEST);
			}
		?>
		<script>make_add_filter_button('template', <?php print $n ? (int)$n : "''"; ?>)</script>

		<div id="moar_filters">
			<hr>
			<p>
				<?php print_text_field("since", "modified since", 20, $_REQUEST); ?>
			</p>
			<p>
				<?php print_text_field("newer", "newer than", 20, $_REQUEST); ?>,
				<?php print_text_field("older", "older than", 20, $_REQUEST); ?>
			</p>
			<p>
				<?php print_text_field("larger", "larger than", 10, $_REQUEST); ?>,
				<?php print_text_field("smaller", "smaller than", 10, $_REQUEST); ?>
			</p>
			
			<?php
				$has_moar = false;
				
				if ( !empty($_REQUEST["since"])
					|| !empty($_REQUEST["newer"])
					|| !empty($_REQUEST["older"])
					|| !empty($_REQUEST["larger"])
					|| !empty($_REQUEST["smaller"]) ) $has_moar = true;
			?>
		</div>
		
		<script>make_toggle_buttons('moar_filters', <?php print $has_moar ? "true" : "false"; ?>)</script>
		
		<p>
			<label for="format">in format</label>
			<select name="format">
				<option value="inline">display</option>
				<option value="json">JSON</option>
				<option value="debug">debug</option>
			</select>
			&nbsp;&nbsp;
			<input type="submit" value="Go!" style="font-weight: bold;"/>
		</p>
	</form>

	<div>
	<?php
	
	# If $op and $format are set, we have a request to handle.
	# This is for HTML output only (format "inline"), output in other formats
	# should have been generated before HTML output started.
	
	if ( $op && $format ) {
		
		# ***** THIS IS WHERE IT ALL HAPPENS! *************************************************
		
		# generate page set and output it. 
		generate_response($format, $wiki, $op, $_REQUEST); 
	}
	?>
	</div>
	
	</div>
</body>
</html>
